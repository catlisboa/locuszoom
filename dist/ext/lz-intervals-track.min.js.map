{"version":3,"sources":["webpack://[name]/webpack/bootstrap","webpack://[name]/webpack/runtime/define property getters","webpack://[name]/webpack/runtime/hasOwnProperty shorthand","webpack://[name]/external \"d3\"","webpack://[name]/./esm/ext/lz-intervals-track.js"],"names":["__webpack_require__","exports","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","d3","XCS","Symbol","for","YCS","XCE","YCE","install","LocusZoom","BaseApiAdapter","Adapters","_Button","Widgets","_BaseWidget","default_layout","start_field","end_field","track_label_field","track_split_field","track_split_order","track_split_legend_to_y_axis","split_tracks","track_height","track_vertical_spacing","bounding_box_padding","always_hide_legend","color","fill_opacity","tooltip_positioning","BaseLayer","DataLayers","intervals_tooltip_layout","namespace","closable","show","or","hide","and","html","intervals_layer_layout","id","type","tag","fields","id_field","field","scale_function","parameters","categories","values","null_value","legend","behaviors","onmouseover","action","status","onmouseout","onclick","exclusive","onshiftclick","tooltip","intervals_panel_layout","min_height","height","margin","top","right","bottom","left","toolbar","l","Layouts","unnamespaced","widgets","push","data_layer_id","position","axes","interaction","drag_background_to_pan","scroll_to_zoom","x_linked","hidden","orientation","origin","x","y","pad_from_bottom","data_layers","intervals_plot_layout","state","width","responsive_resize","min_region_scale","max_region_scale","panels","merge","add","chain","query","header","bedtracksource","this","params","source","chr","end","start","url","layout","super","arguments","_previous_categories","_categories","initialize","_statusnodes_group","svg","group","append","attr","_datanodes_group","data","result","forEach","item","item_key","allow_overlap","grouped_data","index","i","length","row_to_test","last_item","x_scale","parent","_arrangeTrackSplit","_arrangeTracksLinear","keys","reverse","row_index","getTrackHeight","track","reduce","acc","val","concat","element","getBaseId","replace","self","base_layout","_base_layout","render_layout","base_color_scale","find","color_scale","Error","has_colors","has_legend","rgb_option","rgb_field","known_categories","_generateCategoriesFromData","colors","_makeColorScheme","map","pair","shape","label","_applyLayoutOptions","assigned_data","_assignTracks","every","updateSplitTrackAxis","track_data","_applyFilters","selectAll","remove","status_nodes","enter","d","getElementStatusNodeId","cliparea","exit","data_nodes","getElementId","resolveScalableParameter","applyBehaviors","bind","render","x_min","x_max","y_min","y_max","legend_axis","tracks","track_spacing","target_height","scaleHeightToData","ticks","range","findIndex","Math","abs","text","y_axis","axis","floor","ceiling","parent_plot","positionPanels","category_info","n_categories","unique_ids","ScaleFunctions","value","parent_panel","data_layer","button","setHtml","setColor","setTitle","setOnclick","toggleSplitTracks","scale_timeout","clearTimeout","setTimeout","update","use"],"mappings":"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","file":"ext/lz-intervals-track.min.js","sourcesContent":["// The require scope\nvar __webpack_require__ = {};\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","const __WEBPACK_NAMESPACE_OBJECT__ = d3;","/**\n * Interval annotation track (for chromatin state, etc). Useful for BED file data with non-overlapping intervals.\n *  This is not part of the core LocusZoom library, but can be included as a standalone file.\n *\n * ### Features provided\n * * {@link module:LocusZoom_Adapters~IntervalLZ}\n * * {@link module:LocusZoom_Widgets~toggle_split_tracks}\n * * {@link module:LocusZoom_ScaleFunctions~to_rgb}\n * * {@link module:LocusZoom_DataLayers~intervals}\n * * {@link module:LocusZoom_Layouts~standard_intervals}\n * * {@link module:LocusZoom_Layouts~intervals_layer}\n * * {@link module:LocusZoom_Layouts~intervals}\n * * {@link module:LocusZoom_Layouts~interval_association}\n *\n * ### Loading and usage\n * The page must incorporate and load all libraries before this file can be used, including:\n * - LocusZoom\n *\n * To use in an environment without special JS build tooling, simply load the extension file as JS from a CDN (after any dependencies):\n * ```\n * <script src=\"https://cdn.jsdelivr.net/npm/locuszoom@INSERT_VERSION_HERE/dist/ext/lz-intervals-track.min.js\" type=\"application/javascript\"></script>\n * ```\n *\n * To use with ES6 modules, the plugin must be loaded and registered explicitly before use:\n * ```\n * import LocusZoom from 'locuszoom';\n * import IntervalsTrack from 'locuszoom/esm/ext/lz-intervals-track';\n * LocusZoom.use(IntervalsTrack);\n * ```\n *\n * Then use the features made available by this extension. (see demos and documentation for guidance)\n * @module\n */\n\nimport * as d3 from 'd3';\n\n\n// Coordinates (start, end) are cached to facilitate rendering\nconst XCS = Symbol.for('lzXCS');\nconst YCS = Symbol.for('lzYCS');\nconst XCE = Symbol.for('lzXCE');\nconst YCE = Symbol.for('lzYCE');\n\n\nfunction install (LocusZoom) {\n    const BaseApiAdapter = LocusZoom.Adapters.get('BaseApiAdapter');\n    const _Button = LocusZoom.Widgets.get('_Button');\n    const _BaseWidget = LocusZoom.Widgets.get('BaseWidget');\n\n    /**\n     * (**extension**) Retrieve Interval Annotation Data (e.g. BED Tracks), as fetched from the LocusZoom API server (or compatible)\n     * @public\n     * @alias module:LocusZoom_Adapters~IntervalLZ\n     * @see module:LocusZoom_Adapters~BaseApiAdapter\n     * @see {@link module:ext/lz-intervals-track} for required extension and installation instructions\n     * @param {number} config.params.source The numeric ID for a specific dataset as assigned by the API server\n     */\n    class IntervalLZ extends BaseApiAdapter {\n        getURL(state, chain, fields) {\n            const source = chain.header.bedtracksource || this.params.source;\n            const query = `?filter=id in ${source} and chromosome eq '${state.chr}' and start le ${state.end} and end ge ${state.start}`;\n            return `${this.url}${query}`;\n        }\n    }\n\n    /**\n     * (**extension**) Button to toggle split tracks mode in an intervals track. This button only works as a panel-level toolbar\n     *   and when used with an intervals data layer from this extension.\n     * @alias module:LocusZoom_Widgets~toggle_split_tracks\n     * @see module:LocusZoom_Widgets~BaseWidget\n     * @see {@link module:ext/lz-intervals-track} for required extension and installation instructions\n     */\n    class ToggleSplitTracks extends _BaseWidget {\n        /**\n         * @param {string} layout.data_layer_id The ID of the data layer that this button is intended to control.\n         */\n        constructor(layout) {\n            super(...arguments);\n            if (!layout.data_layer_id) {\n                layout.data_layer_id = 'intervals';\n            }\n            if (!this.parent_panel.data_layers[layout.data_layer_id]) {\n                throw new Error('Toggle split tracks widget specifies an invalid data layer ID');\n            }\n        }\n\n        update() {\n            const data_layer = this.parent_panel.data_layers[this.layout.data_layer_id];\n            const html = data_layer.layout.split_tracks ? 'Merge Tracks' : 'Split Tracks';\n            if (this.button) {\n                this.button.setHtml(html);\n                this.button.show();\n                this.parent.position();\n                return this;\n            } else {\n                this.button = new _Button(this)\n                    .setColor(this.layout.color)\n                    .setHtml(html)\n                    .setTitle('Toggle whether tracks are split apart or merged together')\n                    .setOnclick(() => {\n                        data_layer.toggleSplitTracks();\n                        // FIXME: the timeout calls to scale and position (below) cause full ~5 additional re-renders\n                        //  If we can remove these it will greatly speed up re-rendering.\n                        // The key problem here is that the height is apparently not known in advance and is determined after re-render.\n                        if (this.scale_timeout) {\n                            clearTimeout(this.scale_timeout);\n                        }\n                        this.scale_timeout = setTimeout(() => {\n                            this.parent_panel.scaleHeightToData();\n                            this.parent_plot.positionPanels();\n                        }, 0);\n                        this.update();\n                    });\n                return this.update();\n            }\n        }\n    }\n\n\n    /**\n     * (**extension**) Convert a value \"\"rr,gg,bb\" (if given) to a css-friendly color string: \"rgb(rr,gg,bb)\".\n     * This is tailored specifically to the color specification format embraced by the BED file standard.\n     * @alias module:LocusZoom_ScaleFunctions~to_rgb\n     * @param {Object} parameters This function has no defined configuration options\n     * @param {String|null} value The value to convert to rgb\n     * @see {@link module:ext/lz-intervals-track} for required extension and installation instructions\n     */\n    function to_rgb(parameters, value) {\n        return value ? `rgb(${value})` : null;\n    }\n\n    const default_layout = {\n        start_field: 'start',\n        end_field: 'end',\n        track_label_field: 'state_name', // Used to label items on the y-axis\n        // Used to uniquely identify tracks for coloring. This tends to lead to more stable coloring/sorting\n        //  than using the label field- eg, state_ids allow us to set global colors across the entire dataset,\n        //  not just choose unique colors within a particular narrow region. (where changing region might lead to more\n        //  categories and different colors)\n        track_split_field: 'state_id',\n        track_split_order: 'DESC',\n        track_split_legend_to_y_axis: 2,\n        split_tracks: true,\n        track_height: 15,\n        track_vertical_spacing: 3,\n        bounding_box_padding: 2,\n        always_hide_legend: false,\n        color: '#B8B8B8',\n        fill_opacity: 1,\n        tooltip_positioning: 'vertical',\n    };\n\n    const BaseLayer = LocusZoom.DataLayers.get('BaseDataLayer');\n\n    /**\n     * (**extension**) Implements a data layer that will render interval annotation tracks (intervals must provide start and end values)\n     * Each interval (such as from a BED file) will be rendered as a rectangle. All spans can be rendered on the same\n     *  row, or each (auto-detected) category can be rendered as one row per category.\n     *\n     * This layer is intended to work with a variety of datasets with special requirements. As such, it has a lot\n     *  of configuration options devoted to identifying how to fill in missing information (such as color)\n     *\n     * @alias module:LocusZoom_DataLayers~intervals\n     * @see module:LocusZoom_DataLayers~BaseDataLayer\n     * @see {@link module:ext/lz-intervals-track} for required extension and installation instructions\n     */\n    class LzIntervalsTrack extends BaseLayer {\n        /**\n         * @param {string} [layout.start_field='start'] The field that defines interval start position\n         * @param {string} [layout.end_field='end'] The field that defines interval end position\n         * @param {string} [layout.track_label_field='state_name'] Used to label items on the y-axis\n         * @param {string} [layout.track_split_field='state_id'] Used to define categories on the y-axis. It is usually most convenient to use\n         *  the same value for state_field and label_field (eg 1:1 correspondence).\n         * @param {*|'DESC'} [layout.track_split_order='DESC'] When in split tracks mode, should categories be shown in\n         *  the order given, or descending order\n         * @param {number} [layout.track_split_legend_to_y_axis=2]\n         * @param {boolean} [layout.split_tracks=true] Whether to show tracks as merged (one row) or split (many rows)\n         *  on initial render.\n         * @param {number} [layout.track_height=15] The height of each interval rectangle, in px\n         * @param {number} [layout.track_vertical_spacing=3]\n         * @param {number} [layout.bounding_box_padding=2]\n         * @param {boolean} [layout.always_hide_legend=false] Normally the legend is shown in merged mode and hidden\n         *  in split mode. For datasets with a very large number of categories, it may make sense to hide the legend at all times.\n         * @param {string|module:LocusZoom_DataLayers~ScalableParameter[]} [layout.color='#B8B8B8'] The color of each datum rectangle\n         * @param {number|module:LocusZoom_DataLayers~ScalableParameter[]} [layout.fill_opacity=1]\n         * @param {string} [layout.tooltip_positioning='vertical']\n         */\n        constructor(layout) {\n            LocusZoom.Layouts.merge(layout, default_layout);\n            super(...arguments);\n            this._previous_categories = [];\n            this._categories = [];\n        }\n\n        initialize() {\n            super.initialize();\n            this._statusnodes_group = this.svg.group.append('g')\n                .attr('class', 'lz-data-layer-intervals lz-data-layer-intervals-statusnode');\n            this._datanodes_group = this.svg.group.append('g')\n                .attr('class', 'lz-data_layer-intervals');\n        }\n\n        /**\n         * Split data into tracks such that anything with a common grouping field is in the same track\n         * @param data\n         * @return {unknown[]}\n         * @private\n         */\n        _arrangeTrackSplit(data) {\n            const {track_split_field} = this.layout;\n            const result = {};\n            data.forEach((item) => {\n                const item_key = item[track_split_field];\n                if (!Object.prototype.hasOwnProperty.call(result, item_key)) {\n                    result[item_key] = [];\n                }\n                result[item_key].push(item);\n            });\n            return result;\n        }\n\n        /**\n         * Split data into rows using a simple greedy algorithm such that no two items overlap (share same interval)\n         * Assumes that the data are sorted so item1.start always <= item2.start.\n         *\n         * This function can also simply return all data on a single row. This functionality may become configurable\n         *  in the future but for now reflects a lack of clarity in the requirements/spec. The code to split\n         *  overlapping items is present but may not see direct use.\n         */\n        _arrangeTracksLinear(data, allow_overlap = true) {\n            if (allow_overlap) {\n                // If overlap is allowed, then all the data can live on a single row\n                return [data];\n            }\n\n            // ASSUMPTION: Data is given to us already sorted by start position to facilitate grouping.\n            // We do not sort here because JS \"sort\" is not stable- if there are many intervals that overlap, then we\n            //   can get different layouts (number/order of rows) on each call to \"render\".\n            //\n            // At present, we decide how to update the y-axis based on whether current and former number of rows are\n            //  the same. An unstable sort leads to layout thrashing/too many re-renders. FIXME: don't rely on counts\n            const {start_field, end_field} = this.layout;\n\n            const grouped_data = [[]]; // Prevent two items from colliding by rendering them to different rows, like genes\n            data.forEach((item, index) => {\n                for (let i = 0; i < grouped_data.length; i++) {\n                    // Iterate over all rows of the\n                    const row_to_test = grouped_data[i];\n                    const last_item = row_to_test[row_to_test.length - 1];\n                    // Some programs report open intervals, eg 0-1,1-2,2-3; these points are not considered to overlap (hence the test isn't \"<=\")\n                    const has_overlap = last_item && (item[start_field] < last_item[end_field]) && (last_item[start_field] < item[end_field]);\n                    if (!has_overlap) {\n                        // If there is no overlap, add item to current row, and move on to the next item\n                        row_to_test.push(item);\n                        return;\n                    }\n                }\n                // If this item would collide on all existing rows, create a new row\n                grouped_data.push([item]);\n            });\n            return grouped_data;\n        }\n\n        /**\n         * Annotate each item with the track number, and return.\n         * @param {Object[]}data\n         * @private\n         * @return [String[], Object[]] Return the categories and the data array\n         */\n        _assignTracks(data) {\n            // Flatten the grouped data.\n            const {x_scale} = this.parent;\n            const {start_field, end_field, bounding_box_padding, track_height} = this.layout;\n\n            const grouped_data = this.layout.split_tracks ? this._arrangeTrackSplit(data) : this._arrangeTracksLinear(data, true);\n            const categories = Object.keys(grouped_data);\n            if (this.layout.track_split_order === 'DESC') {\n                categories.reverse();\n            }\n\n            categories.forEach((key, row_index) => {\n                const row = grouped_data[key];\n                row.forEach((item) => {\n                    item[XCS] = x_scale(item[start_field]);\n                    item[XCE] = x_scale(item[end_field]);\n                    item[YCS] = row_index * this.getTrackHeight() + bounding_box_padding;\n                    item[YCE] = item[YCS] + track_height;\n                    // Store the row ID, so that clicking on a point can find the right status node (big highlight box)\n                    item.track = row_index;\n                });\n            });\n            // We're mutating elements of the original data array as a side effect: the return value here is\n            //  interchangeable with `this.data` for subsequent usages\n            // TODO: Can replace this with array.flat once polyfill support improves\n            return [categories, Object.values(grouped_data).reduce((acc, val) => acc.concat(val), [])];\n        }\n\n        /**\n         * When we are in \"split tracks mode\", it's convenient to wrap all individual annotations with a shared\n         *  highlight box that wraps everything on that row.\n         *\n         * This is done automatically by the \"setElementStatus\" code, if this function returns a non-null value\n         *\n         * To define shared highlighting on the track split field define the status node id override\n         * to generate an ID common to the track when we're actively splitting data out to separate tracks\n         * @override\n         * @returns {String}\n         */\n        getElementStatusNodeId(element) {\n            if (this.layout.split_tracks) {\n                // Data nodes are bound to data objects, but the \"status_nodes\" selection is bound to numeric row IDs\n                const track = typeof element === 'object' ? element.track : element;\n                const base = `${this.getBaseId()}-statusnode-${track}`;\n                return base.replace(/[^\\w]/g, '_');\n            }\n            // In merged tracks mode, there is no separate status node\n            return null;\n        }\n\n        // Helper function to sum layout values to derive total height for a single interval track\n        getTrackHeight() {\n            return this.layout.track_height\n                + this.layout.track_vertical_spacing\n                + (2 * this.layout.bounding_box_padding);\n        }\n\n        // Modify the layout as necessary to ensure that appropriate color, label, and legend options are available\n        // Even when not displayed, the legend is used to generate the y-axis ticks\n        _applyLayoutOptions() {\n            const self = this;\n            const base_layout = this._base_layout;\n            const render_layout = this.layout;\n            const base_color_scale = base_layout.color.find(function (item) {\n                return item.scale_function && item.scale_function === 'categorical_bin';\n            });\n            const color_scale = render_layout.color.find(function (item) {\n                return item.scale_function && item.scale_function === 'categorical_bin';\n            });\n            if (!base_color_scale) {\n                // This can be a placeholder (empty categories & values), but it needs to be there\n                throw new Error('Interval tracks must define a `categorical_bin` color scale');\n            }\n\n            const has_colors = base_color_scale.parameters.categories.length && base_color_scale.parameters.values.length;\n            const has_legend = base_layout.legend && base_layout.legend.length;\n\n            if (!!has_colors ^ !!has_legend) {\n                // Don't allow color OR legend to be set manually. It must be both, or neither.\n                throw new Error('To use a manually specified color scheme, both color and legend options must be set.');\n            }\n\n            // Harvest any information about an explicit color field that should be considered when generating colors\n            const rgb_option = base_layout.color.find(function (item) {\n                return item.scale_function && item.scale_function === 'to_rgb';\n            });\n            const rgb_field = rgb_option && rgb_option.field;\n\n            // Auto-generate legend based on data\n            const known_categories = this._generateCategoriesFromData(this.data, rgb_field); // [id, label, itemRgb] items\n\n            if (!has_colors && !has_legend) {\n                // If no color scheme pre-defined, then make a color scheme that is appropriate and apply to the plot\n                // The legend must match the color scheme. If we generate one, then we must generate both.\n\n                const colors = this._makeColorScheme(known_categories);\n                color_scale.parameters.categories = known_categories.map(function (item) {\n                    return item[0];\n                });\n                color_scale.parameters.values = colors;\n\n                this.layout.legend = known_categories.map(function (pair, index) {\n                    const id = pair[0];\n                    const label = pair[1];\n                    const item_color = color_scale.parameters.values[index];\n                    const item = { shape: 'rect', width: 9, label: label, color: item_color };\n                    item[self.layout.track_split_field] = id;\n                    return item;\n                });\n            }\n        }\n\n        // Implement the main render function\n        render() {\n            //// Autogenerate layout options if not provided\n            this._applyLayoutOptions();\n\n            // Determine the appropriate layout for tracks. Store the previous categories (y axis ticks) to decide\n            //   whether the axis needs to be re-rendered.\n            this._previous_categories = this._categories;\n            const [categories, assigned_data] = this._assignTracks(this.data);\n            this._categories = categories;\n            // Update the legend axis if the number of ticks changed\n            const labels_changed = !categories.every( (item, index) => item === this._previous_categories[index]);\n            if (labels_changed) {\n                this.updateSplitTrackAxis(categories);\n                return;\n            }\n\n            // Apply filters to only render a specified set of points. Hidden fields will still be given space to render, but not shown.\n            const track_data = this._applyFilters(assigned_data);\n\n            // Clear before every render so that, eg, highlighting doesn't persist if we load a region with different\n            //  categories (row 2 might be a different category and it's confusing if the row stays highlighted but changes meaning)\n            // Highlighting will automatically get added back if it actually makes sense, courtesy of setElementStatus,\n            //  if a selected item is still in view after the new region loads.\n            this._statusnodes_group.selectAll('rect')\n                .remove();\n\n            // Reselect in order to add new data\n            const status_nodes = this._statusnodes_group.selectAll('rect')\n                .data(d3.range(categories.length));\n\n            if (this.layout.split_tracks) {\n                // Status nodes: a big highlight box around all items of the same type. Used in split tracks mode,\n                //  because everything on the same row is the same category and a group makes sense\n                // There are no status nodes in merged mode, because the same row contains many kinds of things\n\n                // Status nodes are 1 per row, so \"data\" can just be a dummy list of possible row IDs\n                // Each status node is a box that runs the length of the panel and receives a special \"colored box\" css\n                //  style when selected\n                const height = this.getTrackHeight();\n                status_nodes.enter()\n                    .append('rect')\n                    .attr('class', 'lz-data_layer-intervals lz-data_layer-intervals-statusnode lz-data_layer-intervals-shared')\n                    .attr('rx', this.layout.bounding_box_padding)\n                    .attr('ry', this.layout.bounding_box_padding)\n                    .merge(status_nodes)\n                    .attr('id', (d) => this.getElementStatusNodeId(d))\n                    .attr('x', 0)\n                    .attr('y', (d) => (d * height))\n                    .attr('width', this.parent.layout.cliparea.width)\n                    .attr('height', height - this.layout.track_vertical_spacing);\n            }\n            status_nodes.exit()\n                .remove();\n\n            // Draw rectangles for the data (intervals)\n            const data_nodes = this._datanodes_group.selectAll('rect')\n                .data(track_data, (d) => d[this.layout.id_field]);\n\n            data_nodes.enter()\n                .append('rect')\n                .merge(data_nodes)\n                .attr('id', (d) => this.getElementId(d))\n                .attr('x', (d) => d[XCS])\n                .attr('y', (d) => d[YCS])\n                .attr('width', (d) => d[XCE] - d[XCS])\n                .attr('height', this.layout.track_height)\n                .attr('fill', (d, i) => this.resolveScalableParameter(this.layout.color, d, i))\n                .attr('fill-opacity', (d, i) => this.resolveScalableParameter(this.layout.fill_opacity, d, i));\n\n            data_nodes.exit()\n                .remove();\n\n            this._datanodes_group\n                .call(this.applyBehaviors.bind(this));\n\n            // The intervals track allows legends to be dynamically generated, in which case space can only be\n            //  allocated after the panel has been rendered.\n            if (this.parent && this.parent.legend) {\n                this.parent.legend.render();\n            }\n        }\n\n        _getTooltipPosition(tooltip) {\n            return {\n                x_min: tooltip.data[XCS],\n                x_max: tooltip.data[XCE],\n                y_min: tooltip.data[YCS],\n                y_max: tooltip.data[YCE],\n            };\n        }\n\n        // Redraw split track axis or hide it, and show/hide the legend, as determined\n        // by current layout parameters and data\n        updateSplitTrackAxis(categories) {\n            const legend_axis = this.layout.track_split_legend_to_y_axis ? `y${this.layout.track_split_legend_to_y_axis}` : false;\n            if (this.layout.split_tracks) {\n                const tracks = +categories.length || 0;\n                const track_height = +this.layout.track_height || 0;\n                const track_spacing = 2 * (+this.layout.bounding_box_padding || 0) + (+this.layout.track_vertical_spacing || 0);\n                const target_height = (tracks * track_height) + ((tracks - 1) * track_spacing);\n                this.parent.scaleHeightToData(target_height);\n                if (legend_axis && this.parent.legend) {\n                    this.parent.legend.hide();\n                    this.parent.layout.axes[legend_axis] = {\n                        render: true,\n                        ticks: [],\n                        range: {\n                            start: (target_height - (this.layout.track_height / 2)),\n                            end: (this.layout.track_height / 2),\n                        },\n                    };\n                    // There is a very tight coupling between the display directives: each legend item must identify a key\n                    //  field for unique tracks. (Typically this is `state_id`, the same key field used to assign unique colors)\n                    // The list of unique keys corresponds to the order along the y-axis\n                    this.layout.legend.forEach((element) => {\n                        const key = element[this.layout.track_split_field];\n                        let track = categories.findIndex((item) => item === key);\n                        if (track !== -1) {\n                            if (this.layout.track_split_order === 'DESC') {\n                                track = Math.abs(track - tracks - 1);\n                            }\n                            this.parent.layout.axes[legend_axis].ticks.push({\n                                y: track - 1,\n                                text: element.label,\n                            });\n                        }\n                    });\n                    this.layout.y_axis = {\n                        axis: this.layout.track_split_legend_to_y_axis,\n                        floor: 1,\n                        ceiling: tracks,\n                    };\n                }\n                // This will trigger a re-render\n                this.parent_plot.positionPanels();\n            } else {\n                if (legend_axis && this.parent.legend) {\n                    if (!this.layout.always_hide_legend) {\n                        this.parent.legend.show();\n                    }\n                    this.parent.layout.axes[legend_axis] = { render: false };\n                    this.parent.render();\n                }\n            }\n            return this;\n        }\n\n        // Method to not only toggle the split tracks boolean but also update\n        // necessary display values to animate a complete merge/split\n        toggleSplitTracks() {\n            this.layout.split_tracks = !this.layout.split_tracks;\n            if (this.parent.legend && !this.layout.always_hide_legend) {\n                this.parent.layout.margin.bottom = 5 + (this.layout.split_tracks ? 0 : this.parent.legend.layout.height + 5);\n            }\n            this.render();\n            return this;\n        }\n\n        // Choose an appropriate color scheme based on the number of items in the track, and whether or not we are\n        //  using explicitly provided itemRgb information\n        _makeColorScheme(category_info) {\n            // If at least one element has an explicit itemRgb, assume the entire dataset has colors\n            const has_explicit_colors = category_info.find((item) => item[2]);\n            if (has_explicit_colors) {\n                return category_info.map((item) => item[2]);\n            }\n\n            // Use a set of color schemes for common 15, 18, or 25 state models, as specified from:\n            //  https://egg2.wustl.edu/roadmap/web_portal/chr_state_learning.html\n            // These are actually reversed so that dim colors come first, on the premise that usually these are the\n            //  most common states\n            const n_categories = category_info.length;\n            if (n_categories <= 15) {\n                return ['rgb(212,212,212)', 'rgb(192,192,192)', 'rgb(128,128,128)', 'rgb(189,183,107)', 'rgb(233,150,122)', 'rgb(205,92,92)', 'rgb(138,145,208)', 'rgb(102,205,170)', 'rgb(255,255,0)', 'rgb(194,225,5)', 'rgb(0,100,0)', 'rgb(0,128,0)', 'rgb(50,205,50)', 'rgb(255,69,0)', 'rgb(255,0,0)'];\n            } else if (n_categories <= 18) {\n                return ['rgb(212,212,212)', 'rgb(192,192,192)', 'rgb(128,128,128)', 'rgb(189,183,107)', 'rgb(205,92,92)', 'rgb(138,145,208)', 'rgb(102,205,170)', 'rgb(255,255,0)', 'rgb(255,195,77)', 'rgb(255,195,77)', 'rgb(194,225,5)', 'rgb(194,225,5)', 'rgb(0,100,0)', 'rgb(0,128,0)', 'rgb(255,69,0)', 'rgb(255,69,0)', 'rgb(255,69,0)', 'rgb(255,0,0)'];\n            } else {\n                // If there are more than 25 categories, the interval layer will fall back to the 'null value' option\n                return ['rgb(212,212,212)', 'rgb(128,128,128)', 'rgb(112,48,160)', 'rgb(230,184,183)', 'rgb(138,145,208)', 'rgb(102,205,170)', 'rgb(255,255,102)', 'rgb(255,255,0)', 'rgb(255,255,0)', 'rgb(255,255,0)', 'rgb(255,195,77)', 'rgb(255,195,77)', 'rgb(255,195,77)', 'rgb(194,225,5)', 'rgb(194,225,5)', 'rgb(194,225,5)', 'rgb(194,225,5)', 'rgb(0,150,0)', 'rgb(0,128,0)', 'rgb(0,128,0)', 'rgb(0,128,0)', 'rgb(255,69,0)', 'rgb(255,69,0)', 'rgb(255,69,0)', 'rgb(255,0,0)'];\n            }\n        }\n\n        /**\n         * Find all of the unique tracks (a combination of name and ID information)\n         * @param {Object} data\n         * @param {String} [rgb_field] A field that contains an RGB value. Aimed at BED files with an itemRgb column\n         * @private\n         * @returns {Array} All [unique_id, label, color] pairs in data. The unique_id is the thing used to define groupings\n         *  most unambiguously.\n         */\n        _generateCategoriesFromData(data, rgb_field) {\n            const self = this;\n            // Use the hard-coded legend if available (ignoring any mods on re-render)\n            const legend = this._base_layout.legend;\n            if (legend && legend.length) {\n                return legend.map((item) => [item[this.layout.track_split_field], item.label, item.color]);\n            }\n\n            // Generate options from data, if no preset legend exists\n            const unique_ids = {}; // make categories unique\n            const categories = [];\n\n            data.forEach((item) => {\n                const id = item[self.layout.track_split_field];\n                if (!Object.prototype.hasOwnProperty.call(unique_ids, id)) {\n                    unique_ids[id] = null;\n                    // If rgbfield is null, then the last entry is undefined/null as well\n                    categories.push([id, item[this.layout.track_label_field], item[rgb_field]]);\n                }\n            });\n            return categories;\n        }\n    }\n\n    /**\n     * (**extension**) A basic tooltip with information to be shown over an intervals datum\n     * @alias module:LocusZoom_Layouts~standard_intervals\n     * @type tooltip\n     * @see {@link module:ext/lz-intervals-track} for required extension and installation instructions\n     */\n    const intervals_tooltip_layout = {\n        namespace: { 'intervals': 'intervals' },\n        closable: false,\n        show: { or: ['highlighted', 'selected'] },\n        hide: { and: ['unhighlighted', 'unselected'] },\n        html: '{{{{namespace[intervals]}}state_name|htmlescape}}<br>{{{{namespace[intervals]}}start|htmlescape}}-{{{{namespace[intervals]}}end|htmlescape}}',\n    };\n\n    /**\n     * (**extension**) A data layer with some preconfigured options for intervals display. This example was designed for chromHMM output,\n     *   in which various states are assigned numeric state IDs and (<= as many) text state names\n     * @alias module:LocusZoom_Layouts~intervals_layer\n     * @type data_layer\n     * @see {@link module:ext/lz-intervals-track} for required extension and installation instructions\n     */\n    const intervals_layer_layout =  {\n        namespace: { 'intervals': 'intervals' },\n        id: 'intervals',\n        type: 'intervals',\n        tag: 'intervals',\n        fields: ['{{namespace[intervals]}}start', '{{namespace[intervals]}}end', '{{namespace[intervals]}}state_id', '{{namespace[intervals]}}state_name', '{{namespace[intervals]}}itemRgb'],\n        id_field: '{{namespace[intervals]}}start',  // FIXME: This is not a good D3 \"are these datums redundant\" ID for datasets with multiple intervals heavily overlapping\n        start_field: '{{namespace[intervals]}}start',\n        end_field: '{{namespace[intervals]}}end',\n        track_split_field: '{{namespace[intervals]}}state_name',\n        track_label_field: '{{namespace[intervals]}}state_name',\n        split_tracks: false,\n        always_hide_legend: true,\n        color: [\n            {\n                // If present, an explicit color field will override any other option (and be used to auto-generate legend)\n                field: '{{namespace[intervals]}}itemRgb',\n                scale_function: 'to_rgb',\n            },\n            {\n                // TODO: Consider changing this to stable_choice in the future, for more stable coloring\n                field: '{{namespace[intervals]}}state_name',\n                scale_function: 'categorical_bin',\n                parameters: {\n                    // Placeholder. Empty categories and values will automatically be filled in when new data loads.\n                    categories: [],\n                    values: [],\n                    null_value: '#B8B8B8',\n                },\n            },\n        ],\n        legend: [], // Placeholder; auto-filled when data loads.\n        behaviors: {\n            onmouseover: [\n                { action: 'set', status: 'highlighted' },\n            ],\n            onmouseout: [\n                { action: 'unset', status: 'highlighted' },\n            ],\n            onclick: [\n                { action: 'toggle', status: 'selected', exclusive: true },\n            ],\n            onshiftclick: [\n                { action: 'toggle', status: 'selected' },\n            ],\n        },\n        tooltip: intervals_tooltip_layout,\n    };\n\n    /**\n     * (**extension**) A panel containing an intervals data layer, eg for BED tracks\n     * @alias module:LocusZoom_Layouts~intervals\n     * @type panel\n     * @see {@link module:ext/lz-intervals-track} for required extension and installation instructions\n     */\n    const intervals_panel_layout = {\n        id: 'intervals',\n        tag: 'intervals',\n        min_height: 50,\n        height: 50,\n        margin: { top: 25, right: 150, bottom: 5, left: 50 },\n        toolbar: (function () {\n            const l = LocusZoom.Layouts.get('toolbar', 'standard_panel', { unnamespaced: true });\n            l.widgets.push({\n                type: 'toggle_split_tracks',\n                data_layer_id: 'intervals',\n                position: 'right',\n            });\n            return l;\n        })(),\n        axes: {},\n        interaction: {\n            drag_background_to_pan: true,\n            scroll_to_zoom: true,\n            x_linked: true,\n        },\n        legend: {\n            hidden: true,\n            orientation: 'horizontal',\n            origin: { x: 50, y: 0 },\n            pad_from_bottom: 5,\n        },\n        data_layers: [intervals_layer_layout],\n    };\n\n    /**\n     * (**extension**) A plot layout that shows association summary statistics, genes, and interval data. This example assumes\n     *  chromHMM data. (see panel layout)\n     * @alias module:LocusZoom_Layouts~interval_association\n     * @type plot\n     * @see {@link module:ext/lz-intervals-track} for required extension and installation instructions\n     */\n    const intervals_plot_layout = {\n        state: {},\n        width: 800,\n        responsive_resize: true,\n        min_region_scale: 20000,\n        max_region_scale: 1000000,\n        toolbar: LocusZoom.Layouts.get('toolbar', 'standard_association', { unnamespaced: true }),\n        panels: [\n            LocusZoom.Layouts.get('panel', 'association'),\n            LocusZoom.Layouts.merge({ unnamespaced: true, min_height: 120, height: 120 }, intervals_panel_layout),\n            LocusZoom.Layouts.get('panel', 'genes'),\n        ],\n    };\n\n    LocusZoom.Adapters.add('IntervalLZ', IntervalLZ);\n    LocusZoom.DataLayers.add('intervals', LzIntervalsTrack);\n\n    LocusZoom.Layouts.add('tooltip', 'standard_intervals', intervals_tooltip_layout);\n    LocusZoom.Layouts.add('data_layer', 'intervals', intervals_layer_layout);\n    LocusZoom.Layouts.add('panel', 'intervals', intervals_panel_layout);\n    LocusZoom.Layouts.add('plot', 'interval_association', intervals_plot_layout);\n\n    LocusZoom.ScaleFunctions.add('to_rgb', to_rgb);\n\n    LocusZoom.Widgets.add('toggle_split_tracks', ToggleSplitTracks);\n}\n\nif (typeof LocusZoom !== 'undefined') {\n    // Auto-register the plugin when included as a script tag. ES6 module users must register via LocusZoom.use()\n    // eslint-disable-next-line no-undef\n    LocusZoom.use(install);\n}\n\n\nexport default install;\n"],"sourceRoot":""}